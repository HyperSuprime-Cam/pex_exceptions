/**
\mainpage lsst::pex::exceptions;  LSST Exceptions

\section secExcIntro Introduction

LSST C++ exceptions are designed to automatically provide information about
where the exception was thrown from.  Exception subclasses can be defined to
more precisely delineate their causes.  Context information can be provided
through a simple message or, in rare cases, additional instance variables
within exception subclasses; caught and rethrown exceptions can have additional
context information appended.

\section secExcPython Python Interface

<b>For Python Users: Catching C++ Exceptions</b>

Python wrappers for the C++ exception objects are generated using SWIG, with
an additional custom wrapper layer on top.  This additional layer allows
the wrapped exceptions to inherit from Python's built-in Exception class,
which is necessary for them to be raised or caught in Python.  These custom
wrappers have the same names as their C++ counterparts.  The immediate Swig
wrappers should not be used by users, and as such are generally renamed or not
imported into a package namespace to hide them.

This means that to catch a C++ exception in Python (we'll use
pex::exceptions::NotFoundError), you can simply use:
@code
try:
    someSwiggedFunction()   # assume this throws NotFoundError
except lsst.pex.exceptions.NotFoundError as err:
    pass
@endcode
In addition, you can catch this same error using either the LSST Exception
base class:
@code
try:
    someSwiggedFunction()   # assume this throws NotFoundError
except lsst.pex.exceptions.Exception as err:
    # Note that 'err' is still the most-derived exception type:
    assert isinstance(err, lsst.pex.exceptions.NotFoundError)
@endcode
or Python's built-in StandardError class (from which all LSST exceptions
inherit):
@code
try:
    someSwiggedFunction()   # assume this throws NotFoundError
except StandardError as err:
    # Once again, 'err' is still the most-derived exception type:
    assert isinstance(err, lsst.pex.exceptions.NotFoundError)
@endcode
In addition, we've multiply-inherited certain LSST exceptions from
obvious Python counterparts:
 - lsst.pex.exceptions.RuntimeError: RuntimeError
 - lsst.pex.exceptions.NotFoundError: LookupError
 - lsst.pex.exceptions.MemoryError: MemoryError
 - lsst.pex.exceptions.OverflowError: OverflowError
 - lsst.pex.exceptions.UnderflowError: ArithmeticError
 - lsst.pex.exceptions.TypeError: TypeError
 - lsst.pex.exceptions.IoError: IOError

This means that there's one more way to catch our NotFoundError:
@code
try:
    someSwiggedFunction()   # assume this throws NotFoundError
except LookupError as err:
    # Once again, 'err' is still the most-derived exception type:
    assert isinstance(err, lsst.pex.exceptions.NotFoundError)
@endcode

When working out what exceptions specifiers will match a given exception,
it's also work keeping in mind that many LSST exceptions inherit from
lsst::pex::exceptions::RuntimeError, and hence inherit indirectly from
Python's RuntimeError.

<b>For Python Users: Raising C++ Exceptions</b>

LSST Exceptions can also be raised just like any other Python exception.
The resulting exception object cannot be passed back to C++ functions,
however, unlike other wrapped C++ objects (this feature could potentially
added if be desired, but currently we see no need for it).

Generally, raising a pure-Python exception is preferred over raising a
wrapped C++ exception.  When some implementations of an interface are
in Swigged C++ and others are in pure-Python, however, it may be better
to raise wrapped C++ exceptions even in the pure-Python implementation,
so calling code that wants to catch exceptions is better insulated from
the choice of implementation language.

<b>For C++ Developers: Invoking Exception Translation</b>

TODO

<b>For C++ Developers: Wrapping New C++ Exceptions</b>

TODO

\section secExcPrinting Printing Exceptions and Tracebacks

TODO

*/
